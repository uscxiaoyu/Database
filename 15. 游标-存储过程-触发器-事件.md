[toc]

## 一、存储过程`stored procedure`

对于`SQL`编程而言，存储对象是数据中的一个重要的对象，它是一组为了完成特定功能的`SQL`语句集，在经过一次编译后，再次调用就不需要重复编译，因此执行效率高。函数和存储过程有以下异同点

- 相同点：
  	- 存储过程和函数的相同点在于，他们都是为了可重复地执行数据库`SQL`语句的集合，并且都是经过一次编译后可直接执行

- 不同点：
  - 语法中实现的标识符不同，`procudure`和`function`
  - 存储过程在创建时无返回值，而函数在定义时必须设置返回值
  - 存储过程没有返回值类型，且不能将结果直接赋值给变量；而函数定义时需要设置返回值类型，且在调用时必须将返回值赋值给变量
  - 存储过程必须通过`CALL`进行调用，不能在`SELECT`语句中调用；函数在`SELECT`语句中调用

### 1. 定义存储过程

```mysql
-- 定义
create procedure 存储过程名(参数1, 参数2, ...)
[存储过程选项]
begin
存储过程语句块;
end;

-- 调用
call <procedure_name>(para1, ...);

-- 删除
drop procedure <procedure_name>;
```
**参数**: 每个参数由3部分组成，分别为输入输出类型、参数名称和参数类型，`[IN | OUT | INOUT] 参数名称 参数类型`

- `IN`表示输入参数，即参数是在调用存储过程时传入到存储过程里面使用，传入的数据可以是直接数据，也可以是变量。
- `OUT`表示输出参数，初始值为`null`，它是将存储过程中的值保持到`out`指定的参数中，返回给调用者。
- `INOUT`表示既可输入也可输出的参数，即参数在调用时传入到存储过程，同时在存储过程中操作之后，又可将数据返回给调用者。

**存储过程选项:**

- `language sql`：说明存储过程体重由`SQL`语言组成
- `[not] deterministic`：存储过程的执行结果是否确定
  - `deterministic`: 相同的输入对应相同的执行过程和结果
  - `not deterministic`: 相同的输入可能得到不同的输出，默认情况
- `sql`选项
	- `contains sql`：包含`SQL`，但不包含读或者写数据的语句，默认情况
	- `no sql`：不包含`SQL`
	- `reads sql data`：包含读数据的`SQL`语句
	- `modifies sql data`：包含写数据的`SQL`语句
- `sql security` 
	-  `definer`：只有定义者有权执行
	-  `invoker`：调用者可执行
-  `comment  '注释'`

#### 示例1:  创建一个新表`test_table`，然后构建一个存储过程，实现把一定数量的数据插入到一个表中

```mysql {.line-numbers}
USE purchase;
CREATE TABLE test_table (id INT AUTO_INCREMENT PRIMARY KEY,
    a VARCHAR(10),
    b VARCHAR(10));
```

```mysql {.line-numbers}
DROP PROCEDURE IF EXISTS insert_many_rows;
DELIMITER $$
CREATE PROCEDURE insert_many_rows (IN loops INT)
    BEGIN
    DECLARE v1 INT;
    SET v1 = loops;
    WHILE v1 > 0 DO
        INSERT INTO test_table(a, b) VALUES ('qpq', 'rst');
        SET v1 = v1 - 1;
    END WHILE;
    END;
$$
DELIMITER ;
```

```mysql {.line-numbers}
-- 调用insert_many_row
CALL insert_many_rows(100);
SELECT * FROM test_table;
```

#### 示例2: 构建一个存储过程，实现把某个类别的产品数量写入到1个变量中

```mysql {.line-numbers}
USE purchase;

delimiter $$
CREATE PROCEDURE sort_count_proc (IN v_sort_id VARCHAR(5), OUT v_product_count INTEGER)
READS SQL DATA
BEGIN
	SELECT COUNT(*) INTO v_product_count
	FROM product
	WHERE sort_id = v_sort_id;
END;
$$
delimiter ;
```

```mysql {.line-numbers}
-- 调用sort_count_proc
SET @v_sort_id = '11';
SET @v_product_count = 0;
CALL sort_count_proc(@v_sort_id, @v_product_count);
SELECT @v_product_count;
```

### 2. 查看存储过程

创建完存储过程后，可以使用`MySQL`专门提供的语句查看存储过程

```mysql
-- 查看存储过程的创建语句
SHOW CREATE PROCEDURE <proc_name>

-- 根据指定的模式查看所有符合要求的存储过程
SHOW PROCEDURE STATUS [LIKE 匹配模式];
```

#### 示例3：查看`insert_many_row`和`sort_count_proc`的定义

```mysql
SHOW CREATE PROCEDURE insert_many_rows;
SHOW CREATE PROCEDURE sort_count_proc;

SHOW PROCEDURE STATUS LIKE 'insert%';
SHOW PROCEDURE STATUS LIKE 'sort_count%';
```

### 3. 存储过程的修改与删除

在`MySQL`中可以使用`ALTER`语句修改存储过程的特性，其基本的语法格式如下

```mysql
ALTER PROCEDURE <proc_name> [properties];
```

上述语句中的特征指的是存储过程中需要修改的部分，注意，`ALTER PROCEDURE`不能修改存储过程的参数或程序题。

- `properties`选项有以下：
  - `comment`
  - `language sql`
  - `contain sql`
  - `no sql`
  - `reads sql data`
  - `modifies sql data`
  - `sql security defineer`
  - `sql security invoker`

#### 示例4: 修改`sort_count_proc`定义

```mysql
ALTER PROCEDURE sort_count_proc
SQL SECURITY INVOKER
COMMENT '统计某一个类别下的产品数量';
```

### 4. 存储过程的错误处理

在存储过程执行过程中，可对某些特定的错误代码、警告或异常进行定义，然后针对这些错误添加处理程序进行进一步的处理。

- 自定义错误名称

```mysql
DECLARE 异常名称 CONDITION FOR [错误类型];
```

在上述语法中，错误类型由两种可选值，分别为`mysql_error_code`和`SQLSTATE[VALUE] sqlstate_value`。前者是数值类型表示的错误代码，如`1148`；后者是5个字符长度的错误代码，如 `SQLSTATE '42000'`。

#### 示例5：为错误状态定义名称

```mysql
DELIMITER $$
CREATE PROCEDURE exp_proc_1()
BEGIN
	DECLARE command_not_allowed CONDITION FOR SQLSTATE '42000';  -- SQLSTATE
END
$$
DELIMITER ;

-- 或者
DELIMITER $$
CREATE PROCEDURE exp_proc_2()
BEGIN
	DECLARE command_not_allowed CONDITION FOR 1148; -- MYSQL_ERROR_CODE
END
$$
DELIMITER ;
```

- 错误的处理程序

```mysql
DECLARE 错误处理方式 HANDLER FOR 错误类型 [, 错误类型] ... 程序语句块；
```

*错误类型*包括`CONTINUE`（遇到错误不处理，继续执行），另一种是`EXIT`（遇到错误时马上退出）；*程序语句段*表示遇到定义的错误时，需要执行的存储过程代码块。`FOR`后的错误类型可选值有6种：

- `MYSQL_ERROR_CODE`
- `SQLSTATE`
- `SQLWARING`表示所有以01开头的`SQLSTATE`代码
- `NOT FOUND`表示所有以02开头的`SQLSTATE`代码
- `SQLEXCEPTION`表示所有以01或02开头外的所有`SQLSTATE`代码

#### 示例6：定义存储程序，往`sort`表插入数据行，如果插入成功，则设置会话变量为0；如果插入重复值，则设置会话变量为1.
 > `SQLSTATE '23000'`或者`1062`表示插入行时，表中已包含重复键，因此不能插入。

```mysql
ALTER TABLE sort MODIFY sort_id CHAR(2) PRIMARY KEY;
DELIMITER $$
CREATE PROCEDURE proc_demo(v_sortid, v_sort_name)
BEGIN
	DECLARE CONTINUE HANDLER FOR SQLSTATE '23000'
		SET @is_success = 0; -- 如果遇到23000错误，则执行set @num=1，并继续之后的语句
	SET @is_success = 1;
	INSERT INTO sort(sort_id, sort_name) VALUES (v_sortid, v_sortname);
END
$$
DELIMITER ;

-- 分别执行两次，第一次成功;第二次未成功，但未报错，说明已经处理了异常。
call proc_demo('99', '其它'); 
select @is_success;
```

## 二、 游标`cursor`

>- a. 声明游标
`declare 游标名 cursor for select 语句`
使用`declare`语句声明游标后，此时与游标对应的`select`语句并没有执行，`mysql`服务器内存中并不存在与`select`语句对应的结果集。
>- b. 打开游标
`open 游标名`
此时对应的`select`语句被执行，`mysql`服务器内存中存在与`select`语句对应的结果集。
>- c. 从游标中提出数据 
`fetch 游标名 into 变量名1, 变量名2, ...`
每提取一条记录，游标移到下一条记录的开头。当取出最后一条记录后，如果再次执行`fetch`语句，则产生`"ERROR 1329(02000):No data to fetch"`。
>- d. 关闭游标 
`close 游标名`
释放游标打开的数据集，以节省`mysql`服务器的内存空间。如果没有被明确关闭，则它将再被打开的`begin-end`语句块的末尾关闭。

#### 示例3: 更新某一类产品的所有产品的价格：如果大于1000，则上涨5%；否则，上涨10%。

```mysql {.line-numbers}
DROP PROCEDURE IF EXISTS update_price_proc;
delimiter $$
CREATE PROCEDURE update_price_proc (IN v_sort_name VARCHAR(20))
MODIFIES SQL DATA
BEGIN
	DECLARE v_product_id INT;
	DECLARE v_price DECIMAL(8, 2);
	DECLARE state CHAR(20);
	DECLARE price_cur CURSOR FOR 
				SELECT product_id, price 
        FROM product natural JOIN sort 
        WHERE sort_name = v_sort_name;
	DECLARE CONTINUE HANDLER FOR 1329 SET state = 'Error';  -- continue 发生错误继续运行， exit 发生错误终止程序
	OPEN price_cur; -- 打开游标
	REPEAT
		FETCH price_cur INTO v_product_id, v_price;  -- 移动游标，获取数据
			IF (v_price > 1000) THEN 
				SET v_price = v_price * 1.05;
			ELSE 
				SET v_price = v_price * 1.1;
			END IF;
            
			UPDATE product 
            SET price = v_price 
            WHERE product_id = v_product_id;
		UNTIL state = 'Error'  -- 如果没发生异常，则state为null；如果发生1329异常，state的值为error，此时终止repeat
	END REPEAT;
	CLOSE price_cur;  -- 关闭游标
END;
$$
delimiter ;
```
- 调用存储过程
```mysql
SELECT product_id, price 
FROM product natural JOIN sort 
WHERE sort_name = '办公机器设备';

CALL update_price_proc('办公机器设备');
SELECT * FROM instructor WHERE dept_name='Comp. Sci.';
```

## 三、触发器 

触发器的行为由数据操纵行为自动触发，因此一旦定义好，即可实现自动管理数据表。一些数据库的完整约束（如主键约束、外键约束和用户自定义约束等）可以基于触发器实现。

基本语法

```mysql
CREATE TRIGGER 触发器名 触发时间 触发事件 ON 表名 FOR EACH ROW
BEGIN
	触发程序
END;
```

- 触发时间: `before / after`，在事件发生前或后做触发程序。
- 触发事件: `insert / update / delete`，表上的触发时间
- `for each row`: 行级触发器(`mysql`目前仅支持行级触发器，不支持语句级别的触发器, 如`create table`)
- 触发程序中的`select`语句不能产生结果集
- 触发程序中可以使用`old`和`new`关键字区别更新前后的行值
- `old`是只读的，可以引用，但不能更改。在`before`触发程序中，可使用`"set new.col_name = value"`更改`new`值。但在`after`触发程序中，不能使用`"set new.col_name = value"`.

##### 示例4: 不允许`instructor`的薪水值高于150000

```mysql
CREATE TABLE `instructor` (`id` CHAR(5) PRIMARY KEY, 
                         `name` VARCHAR(20), 
                         `dept_name` VARCHAR(20), 
                         `salary` DECIMAL(8, 2));

INSERT INTO instructor (id, `name`, dept_name, salary)
VALUES ('10101', 'Srinivasan', 'Comp. Sci.', '65000.00'),
      ('12121', 'Wu', 'Finance', '90000.00'),
      ('15151', 'Mozart', 'Music', '40000.00'),
      ('22222', 'Einstein', 'Physics', '95000.00'),
      ('32343', 'EI Said', 'History', '60000.00'),
      ('33456', 'Gold', 'Physics', '87000.00'),
      ('45565', 'Katz', 'Comp. Sci.', '75000.00'),
      ('58583', 'Califieri', 'History', '62000.00'),
      ('76543', 'Singh', 'Finance', '80000.00'),
      ('76766', 'Crick', 'Biology', '72000.00'),
      ('83821', 'Brandt', 'Comp. Sci.', '92000.00'),
      ('98345', 'Kim', 'Elec. Eng.', '80000.00');
```

- 分析：对于任意的数据操作，不允许更新后的薪水高于15000。
  - 插入一条或多条新记录，其中某行的薪水值高于15000
  - 修改一条或多条记录，其中修改后某行的薪水值高于15000

- [ ] `update`

```mysql {.line-numbers}
delimiter $$
create trigger instru_update_before_trigger before update on instructor for each row
begin
    if (new.salary > 150000) then -- new为更新前的行值
        set new.salary = old.salary;  -- 如果高于150000，则重新更新为原来的值
        insert into mytable values(0); -- 触发异常，更新失败，因为mytable未经定义
    end if;
end;
$$
delimiter ;
```

- [ ] `insert`

```mysql {.line-numbers}
delimiter $$
create trigger instru_insert_before_trigger before insert on instructor for each row
begin
    if (new.salary > 150000) then
        insert into mytable values(0);  -- 触发异常，更新失败，因为mytable未经定义
    end if;
end;
$$
delimiter ;
```

- [ ] 完成定义

```mysql {.line-numbers}
show triggers; -- 查看触发器
```

##### 根据插入条件触发

```sql {.line-numbers}
select * from instructor;
update instructor set salary=185000 where id='10101';
insert into instructor values('11111', 'Steve', 'Finance', 160000);
delete from instructor where id='11111';
```

#### 示例5：利用触发器实现`sort`表和`subsort`表之间的外键约束：`subsort`表的`sort_id`参照`sort`表的`sort_id`。

- 分析：需要分别定义从表和主表的更新和删除行为（`before`）
  - 主表：
    - 删除一行时，检查从表中是否存在参照值
    - 更新一行时，检查从表中是否存在参照行值，可进一步定义从表的参照值是否也对应更新（cascade）
  - 从表：
    - 新增一行时，检查主表是否存在被参照值，如果不存在，则插入失败。
    - 更新一行时，检查主表是否存在被参照值，如果不存在，则更新失败。



## 四、事件`event`



## 五、应用

### 1. 迭代查询

- 创建prereq表

```mysql
USE purchase;
CREATE TABLE prereq (course_id varchar(30) primary key, 
                     prereq_id varchar(30));
                     
INSERT INTO prereq(course_id, prereq_id)
VALUES ('BIO-301', 'BIO-101'),
('BIO-399', 'BIO-101'),
('CS-190', 'CS-101'),
('CS-315', 'CS-101'),
('CS-319', 'CS-101'),
('CS-347', 'CS-101'),
('EE-181', 'PHY-101'),
('CS-101', 'CS-10'),
('CS-10', 'CS-1');
```

#### 示例4：基于存储过程结合临时表实现对prereq表的迭代查询。

```mysql
-- mysql8版本可以用with recursive实现
-- 查询课程号'CS-10'机器所有的子课程
with recursive tree_course(course_id, prereq_id, lev) as (
	select course_id, prereq_id, 0 as lev 
	from prereq 
	where course_id = 'CS-10'
	union all
	select s.course_id, s.prereq_id, p.lev + 1 as lev
	from tree_course p join prereq s on p.course_id = s.prereq_id)
select * from tree_course;

select * from prereq;
```

```mysql
-- mysql5.7之前的版本
DROP PROCEDURE IF EXISTS purchase.tree_prereq_proc;

DELIMITER $$
CREATE PROCEDURE tree_prereq_proc(v_course_id varchar(30))
MODIFIES SQL DATA
BEGIN
	DECLARE v_lev INT DEFAULT 0;
	DROP TEMPORARY TABLE IF EXISTS tree_prereq; -- 要点1
	CREATE TEMPORARY TABLE tree_prereq(course_id varchar(30), 
									 prereq_id varchar(30),
									 lev int); -- 用于存储结果
	REPEAT
	INSERT INTO tree_prereq(course_id, prereq_id, lev)
    SELECT course_id, prereq_id, v_lev as lev
    FROM prereq
    WHERE course_id = v_course_id; -- 首轮节点对应的子节点
  
	WHILE row_count() > 0 DO -- 要点2
		DROP TEMPORARY TABLE if exists temp; 
		CREATE TEMPORARY TABLE temp -- 要点3
			SELECT * FROM tree_prereq WHERE lev = v_lev;
		SET v_lev = v_lev + 1; -- 更新层级
		INSERT INTO tree_prereq(course_id, prereq_id, lev)
			SELECT distinct s.course_id, s.prereq_id, v_lev as lev
			FROM temp p JOIN prereq s ON p.course_id = s.prereq_id; -- 要点4
	END WHILE;
END;
$$
DELIMITER ;

-- 
CALL tree_prereq_proc('CS-10');
SELECT * FROM tree_prereq;
```

> 要点
>
> 1. 初始化结果集：存储过程中的数据定义语句直接提交，需先删除已经存在的`tree_prereq`，否则建表执行不成功
> 2. `row_count()`可得到上一个`SQL`语句影响的行数，因此，若`INSERT`语句没有新行插入到`tree_prereq`表中，则`row_count()=0`，跳出循环。
> 3. 创建当前轮循环的种子行
> 4. `temp p JOIN prereq s ON p.course_id = s.prereq_id`其中`temp`中的行作为父节点表，`prereq`中的行作为子节点表。

### 2.



