[toc]

## 一、存储过程`stored procedure`

对于SQL编程而言，存储对象是数据中的一个重要的对象，它是一组为了完成特定功能的SQL语句集，在经过一次编译后，再次调用就不需要重复编译，因此执行效率高。与函数相比，存储过程

语法

```mysql
-- 定义
create procedure 存储过程名(参数1, 参数2, ...)
[存储过程选项]
begin
存储过程语句块;
end;

-- 调用
call <procedure_name>(para1, ...);

-- 删除
drop procedure <procedure_name>;
```
**参数**: 每个参数由3部分组成，分别为输入输出类型、参数名称和参数类型，`[IN | OUT | INOUT] 参数名称 参数类型`

- `IN`表示输入参数，`OUT`表示输出参数，`INOUT`表示既可输入也可输出的参数

**存储过程选项:**

- `language sql`：说明存储过程体重由SQL语言组成
- `[not] deterministic`：存储过程的执行结果是否确定
  - deterministic: 相同的输入对应相同的执行过程和结果
  - not deterministic: 相同的输入可能得到不同的输出，默认情况
- `sql`选项
	- contains sql：包含SQL，但不包含读或者写数据的语句，默认情况
	- no sql：不包含SQL
	- reads sql data：包含读数据的SQL语句
	- modifies sql data：包含写数据的SQL语句
- `sql security` 
	-  definer
	-  invoker
-  `comment  '注释'`

#### 示例1:  创建一个新表`test_table`，然后构建一个存储过程，实现把一定数量的数据插入到一个表中

```mysql {.line-numbers}
USE purchase;
CREATE TABLE test_table (id INT AUTO_INCREMENT PRIMARY KEY,
    a VARCHAR(10),
    b VARCHAR(10));
```

```mysql {.line-numbers}
DROP PROCEDURE IF EXISTS insert_many_rows;
DELIMITER $$
CREATE PROCEDURE insert_many_rows (IN loops INT)
    BEGIN
    DECLARE v1 INT;
    SET v1 = loops;
    WHILE v1 > 0 DO
        INSERT INTO test_table(a, b) VALUES ('qpq', 'rst');
        SET v1 = v1 - 1;
    END WHILE;
    END;
$$
DELIMITER ;
```

```mysql {.line-numbers}
-- 调用insert_many_row
CALL insert_many_rows(100);
SELECT * FROM test_table;
```

#### 示例2: 构建一个存储过程，实现把某个部门的员工数量写入到1个变量中

```mysql {.line-numbers}
USE purchase;

delimiter $$
CREATE PROCEDURE sort_count_proc (IN v_sort_id VARCHAR(5), OUT v_product_count INTEGER)
READS SQL DATA
BEGIN
	SELECT COUNT(*) INTO v_product_count
	FROM product
	WHERE sort_id = v_sort_id;
END;
$$
delimiter ;
```

```mysql {.line-numbers}
-- 调用sort_count_proc
SET @v_sort_id = '11';
SET @v_product_count = 0;
CALL sort_count_proc(@v_sort_id, @v_product_count);
SELECT @v_product_count;
```

## 二、 游标`cursor`

>- a. 声明游标
`declare 游标名 cursor for select 语句`
使用`declare`语句声明游标后，此时与游标对应的`select`语句并没有执行，`mysql`服务器内存中并不存在与`select`语句对应的结果集。
>- b. 打开游标
`open 游标名`
此时对应的`select`语句被执行，`mysql`服务器内存中存在与`select`语句对应的结果集。
>- c. 从游标中提出数据 
`fetch 游标名 into 变量名1, 变量名2, ...`
每提取一条记录，游标移到下一条记录的开头。当取出最后一条记录后，如果再次执行`fetch`语句，则产生`"ERROR 1329(02000):No data to fetch"`。
>- d. 关闭游标 
`close 游标名`
释放游标打开的数据集，以节省`mysql`服务器的内存空间。如果没有被明确关闭，则它将再被打开的`begin-end`语句块的末尾关闭。

#### 示例3: 更新某一类产品的所有产品的价格：如果大于1000，则上涨5%；否则，上涨10%。

```mysql {.line-numbers}
DROP PROCEDURE IF EXISTS update_price_proc;
delimiter $$
CREATE PROCEDURE update_price_proc (IN v_sort_name VARCHAR(20))
MODIFIES SQL DATA
BEGIN
	DECLARE v_product_id INT;
	DECLARE v_price DECIMAL(8, 2);
	DECLARE state CHAR(20);
	DECLARE price_cur CURSOR FOR 
				SELECT product_id, price 
        FROM product natural JOIN sort 
        WHERE sort_name = v_sort_name;
	DECLARE CONTINUE HANDLER FOR 1329 SET state = 'Error';  -- continue 发生错误继续运行， exit 发生错误终止程序
	OPEN price_cur; -- 打开游标
	REPEAT
		FETCH price_cur INTO v_product_id, v_price;  -- 移动游标，获取数据
			IF (v_price > 1000) THEN 
				SET v_price = v_price * 1.05;
			ELSE 
				SET v_price = v_price * 1.1;
			END IF;
            
			UPDATE product 
            SET price = v_price 
            WHERE product_id = v_product_id;
		UNTIL state = 'Error'  -- 如果没发生异常，则state为null；如果发生1329异常，state的值为error，此时终止repeat
	END REPEAT;
	CLOSE price_cur;  -- 关闭游标
END;
$$
delimiter ;
```
- 调用存储过程
```mysql
SELECT product_id, price 
FROM product natural JOIN sort 
WHERE sort_name = '办公机器设备';

CALL update_price_proc('办公机器设备');
SELECT * FROM instructor WHERE dept_name='Comp. Sci.';
```

## 三、触发器 

触发器的行为由数据操纵行为自动触发，因此一旦定义好，即可实现自动管理数据表。一些数据库的完整约束（如主键约束、外键约束和用户自定义约束等）可以基于触发器实现。

基本语法

```mysql
CREATE TRIGGER 触发器名 触发时间 触发事件 ON 表名 FOR EACH ROW
BEGIN
	触发程序
END;
```

- 触发时间: `before / after`，在事件发生前或后做触发程序。
- 触发事件: `insert / update / delete`，表上的触发时间
- `for each row`: 行级触发器(`mysql`目前仅支持行级触发器，不支持语句级别的触发器, 如`create table`)
- 触发程序中的`select`语句不能产生结果集
- 触发程序中可以使用`old`和`new`关键字区别更新前后的行值
- `old`是只读的，可以引用，但不能更改。在`before`触发程序中，可使用`"set new.col_name = value"`更改`new`值。但在`after`触发程序中，不能使用`"set new.col_name = value"`.

##### 示例4: 不允许`instructor`的薪水值高于150000

```mysql
CREATE TABLE `instructor` (`id` CHAR(5) PRIMARY KEY, 
                         `name` VARCHAR(20), 
                         `dept_name` VARCHAR(20), 
                         `salary` DECIMAL(8, 2));

INSERT INTO instructor (id, `name`, dept_name, salary)
VALUES ('10101', 'Srinivasan', 'Comp. Sci.', '65000.00'),
      ('12121', 'Wu', 'Finance', '90000.00'),
      ('15151', 'Mozart', 'Music', '40000.00'),
      ('22222', 'Einstein', 'Physics', '95000.00'),
      ('32343', 'EI Said', 'History', '60000.00'),
      ('33456', 'Gold', 'Physics', '87000.00'),
      ('45565', 'Katz', 'Comp. Sci.', '75000.00'),
      ('58583', 'Califieri', 'History', '62000.00'),
      ('76543', 'Singh', 'Finance', '80000.00'),
      ('76766', 'Crick', 'Biology', '72000.00'),
      ('83821', 'Brandt', 'Comp. Sci.', '92000.00'),
      ('98345', 'Kim', 'Elec. Eng.', '80000.00');
```

- 分析：对于任意的数据操作，不允许更新后的薪水高于15000。
  - 插入一条或多条新记录，其中某行的薪水值高于15000
  - 修改一条或多条记录，其中修改后某行的薪水值高于15000

- [ ] `update`

```mysql {.line-numbers}
delimiter $$
create trigger instru_update_before_trigger before update on instructor for each row
begin
    if (new.salary > 150000) then -- new为更新前的行值
        set new.salary = old.salary;  -- 如果高于150000，则重新更新为原来的值
        insert into mytable values(0); -- 触发异常，更新失败，因为mytable未经定义
    end if;
end;
$$
delimiter ;
```

- [ ] `insert`

```mysql {.line-numbers}
delimiter $$
create trigger instru_insert_before_trigger before insert on instructor for each row
begin
    if (new.salary > 150000) then
        insert into mytable values(0);  -- 触发异常，更新失败，因为mytable未经定义
    end if;
end;
$$
delimiter ;
```

- [ ] 完成定义

```mysql {.line-numbers}
show triggers; -- 查看触发器
```

##### 根据插入条件触发

```sql {.line-numbers}
select * from instructor;
update instructor set salary=185000 where id='10101';
insert into instructor values('11111', 'Steve', 'Finance', 160000);
delete from instructor where id='11111';
```

#### 示例5：利用触发器实现`sort`表和`subsort`表之间的外键约束：`subsort`表的`sort_id`参照`sort`表的`sort_id`。

- 分析：需要分别定义从表和主表的更新和删除行为（`before`）
  - 主表：
    - 删除一行时，检查从表中是否存在参照值
    - 更新一行时，检查从表中是否存在参照行值，可进一步定义从表的参照值是否也对应更新（cascade）
  - 从表：
    - 新增一行时，检查主表是否存在被参照值，如果不存在，则插入失败。
    - 更新一行时，检查主表是否存在被参照值，如果不存在，则更新失败。



## 四、事件`event`



## 五、应用

### 1. 迭代查询

- 创建prereq表

```mysql
USE purchase;
CREATE TABLE prereq (course_id varchar(30) primary key, 
                     prereq_id varchar(30));
                     
INSERT INTO prereq(course_id, prereq_id)
VALUES ('BIO-301', 'BIO-101'),
('BIO-399', 'BIO-101'),
('CS-190', 'CS-101'),
('CS-315', 'CS-101'),
('CS-319', 'CS-101'),
('CS-347', 'CS-101'),
('EE-181', 'PHY-101'),
('CS-101', 'CS-10'),
('CS-10', 'CS-1');
```

#### 示例4：基于存储过程结合临时表实现对prereq表的迭代查询。

```mysql
-- mysql8版本可以用with recursive实现
-- 查询课程号'CS-10'机器所有的子课程
with recursive tree_course(course_id, prereq_id, lev) as (
	select course_id, prereq_id, 0 as lev 
	from prereq 
	where course_id = 'CS-10'
	union all
	select s.course_id, s.prereq_id, p.lev + 1 as lev
	from tree_course p join prereq s on p.course_id = s.prereq_id)
select * from tree_course;

select * from prereq;
```

```mysql
-- mysql5.7之前的版本
DROP PROCEDURE IF EXISTS purchase.tree_prereq_proc;

DELIMITER $$
CREATE PROCEDURE tree_prereq_proc(v_course_id varchar(30))
MODIFIES SQL DATA
BEGIN
	DECLARE v_lev INT DEFAULT 0;
	DROP TEMPORARY TABLE IF EXISTS tree_prereq; -- 要点1
	CREATE TEMPORARY TABLE tree_prereq(course_id varchar(30), 
									 prereq_id varchar(30),
									 lev int); -- 用于存储结果
	REPEAT
	INSERT INTO tree_prereq(course_id, prereq_id, lev)
    SELECT course_id, prereq_id, v_lev as lev
    FROM prereq
    WHERE course_id = v_course_id; -- 首轮节点对应的子节点
  
	WHILE row_count() > 0 DO -- 要点2
		DROP TEMPORARY TABLE if exists temp; 
		CREATE TEMPORARY TABLE temp -- 要点3
			SELECT * FROM tree_prereq WHERE lev = v_lev;
		SET v_lev = v_lev + 1; -- 更新层级
		INSERT INTO tree_prereq(course_id, prereq_id, lev)
			SELECT distinct s.course_id, s.prereq_id, v_lev as lev
			FROM temp p JOIN prereq s ON p.course_id = s.prereq_id; -- 要点4
	END WHILE;
END;
$$
DELIMITER ;

-- 
CALL tree_prereq_proc('CS-10');
SELECT * FROM tree_prereq;
```

> 要点
>
> 1. 初始化结果集：存储过程中的数据定义语句直接提交，需先删除已经存在的`tree_prereq`，否则建表执行不成功
> 2. `row_count()`可得到上一个`SQL`语句影响的行数，因此，若`INSERT`语句没有新行插入到`tree_prereq`表中，则`row_count()=0`，跳出循环。
> 3. 创建当前轮循环的种子行
> 4. `temp p JOIN prereq s ON p.course_id = s.prereq_id`其中`temp`中的行作为父节点表，`prereq`中的行作为子节点表。

### 2.



