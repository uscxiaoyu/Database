[toc]

## 1. 衍生列（`generated column`）

在基础列的上，通过一定的运算转换而定义生成的列，即为衍生列。

```mysql
CREATE TABLE <t_name> (
	col <col_type>,
  g_col <col_type> GENERATED ALWAYS AS (<computation on col>) [stored | virtual] [NOT NULL] [PRIMARY KEY]
    );
```

- 有两种类型的衍生列：`stored`和`virtual`，默认为`virtual`

  - `stored `意味着有物理空间直接存储生成列的值，可以在上面建立聚集或二级索引；
  - `virtual`意味着在查询该字段时生成对应的列值，不能直接在其上建立二级索引。

  >**来源: 官方文档**
  >
  >每张使用`Innodb`作为存储引擎的表都有一个聚簇索引，以保存每行数据的存储位置。一般情况，聚簇索引就是主键索引。为了得到最高效的查询、插入，或者其他的数据库操作，你必须理解`innodb`引擎如何使用聚簇索引来优化大多数查询和dml操作的。
  >
  >
  >
  >**`Innodb`如何选择聚集索引？**
  >
  >如果你为表定义了一个主键，`innodb`就使用它作为聚簇索引。
  >
  >如果你没有定义主键，`mysql`选择非空类型的唯一索引来作为作为主键，并且`innodb`会用它作为聚簇索引。
  >
  >如果表中既没有主键，又没有合适的唯一索引，`innodb`内部生成一个隐式聚簇索引，建在由`rowid`组成的虚拟列上。在这张表中，`innodb`为每行数据指定一个`rowid`，数据行根据`ID`来排序。这些`rowid`是由一些占6字节空间的自增长列组成。当有新数据插入的时候，`rowid`增长，这样，保证`rowid`就是按照数据的物理写入顺序来组织行。
  >
  >
  >
  >**聚簇索引提高了查询效率？**
  >
  >通过聚簇索引来寻找一行数据是非常快的，这是因为行数据和索引在同一页上。如果表特别大，聚簇索引的这种构造就能节省磁盘`I/O`资源（索引和数据在不同页上时，根据索引来寻找数据存储页消耗的IO），比如`myisam`引擎，把索引和数据页分开存放；
  >
  >
  >
  >**二级索引和聚簇索引之间是如何关联的？**
  >
  >除了聚簇索引之外的其他索引类型都属于二级索引。在`Innodb`中，二级索引的每行数据都包含这条数据的主键列，还有二级索引指定的列；聚簇索引中，`innodb`通过主键值来查找数据行。
  >
  >如果主键过长，二级索引就需要更大的空间，因此，使用短的主键列是非常有用的。

- 生成列的构建可包含字面量、确定性内建函数和操作符、基本列、创建于其前的生成列。

- 以下不允许出现在生成列定义中
  - 不确性内建函数如`current_date(), current_timestamp(),connection_id()`等
  - 用户自定义存储过程，系统、用户、局部变量等
  - 子查询
  - 在其后定义的生成列
  - `auto_increment`

- 使用`create table ... like `可保留原表中的生成列定义；使用`create table ... select`则不能。

- 生成列的使用场景：

  - 简化和整合查询。复杂条件可通过生成列表示，查询可直接指向该列，从而保证查询条件的一致性。

  - 作为复杂条件或运算的物化存储，提前缓存，从而减少查询时间

  - 模拟函数索引，如可在`json`列中的某些子属性创建生成列，进而构建索引。（缺点在于，该属性数据需存储两次）

    - > ```mysql
      > CREATE TABLE jemp (
      >   c JSON,
      >   g INT GENERATED ALWAYS AS (c->"$.id"),
      >   INDEX i (g));
      > ```

  - 查询优化器可识别出使用了生成列定义的查询，从而可利用创建在生成列上的索引，即便该查询未直接使用该列。

- 生成列的使用限制

  - 生成列不能作为被参照列。
  - 参照列上的外键约束`on update`选项不能设为`cascade, set_null,set default`；`on delete`选项不能设为`set null,set default`
  - 触发器中不能用`new.col_name`和`old.col_name`指代生成列

```mysql
drop table if exists person;

CREATE TABLE person(
  id int primary key,
  first_name varchar(20) not null,
  last_name varchar(20) not null,
  `name` varchar(50) generated always as (concat(first_name, ' ', last_name)) stored,
  index idx_name (`name`));

alter table person modify `name` varchar(50) generated always as (concat(first_name, ' ', last_name)) stored;

show create table person;

delete from person;
insert into person(id, first_name, last_name)
values (1, 'Mike', 'James');

select * from person;
```

## 2. `json`类型

### 2.1 数组

```mysql
SELECT JSON_ARRAY("abc", 10, null, true, false);
SELECT CAST('["abc", 10, null, true, false]' as JSON);
SELECT convert('["abc", 10, null, true, false]', JSON);
```

- 创建`json`类型的属性

```mysql
CREATE TABLE t(id int, c JSON);
```

- 插入`json array`值

```mysql
INSERT INTO t(c) VALUES('[1, 2, [0, 1]]');  -- 插入数组[1, 2, [0, 1]]
INSERT INTO t SET c = '[1, "2", ["0", 1]]'; -- 插入数组[1, "2", ["0", 1]]
```

- 查询`json`中的元素

```mysql
SELECT c->'$[2][0]' FROM t;
SELECT * FROM t;

-- 判断json列中是否包含某个值
SELECT JSON_CONTAINS(c, '"2"', '$[1]') -- 返回c中第二个元素是否为"2"的判断（0或1）
FROM t;
```

> `$`指代根列名

- 搜索某个子元素的位置

```mysql
-- 某个值的引用
SELECT JSON_SEARCH(c, 'all', '2')
FROM t;
```

- 在`json array`中添加元素: `JSON_ARRAY_APPEND,JSON_ARRAY_INSERT `

```mysql
-- 末尾添加元素JSON_ARRAY_APPEND
SET @j = '["a", ["b", "c"], "d"]';
SELECT JSON_ARRAY_APPEND(@j, '$[2]', 1), JSON_ARRAY_APPEND(@j, '$', 1); 

SET @k = '{"a": 1}';
SELECT JSON_ARRAY_APPEND(@k, '$.a', 'z'), JSON_ARRAY_APPEND(@k, '$', 'z');

-- 数组插入元素JSON_ARRAY_INSERT
SET @j = '["a", ["b", "c"], "d"]';
SELECT JSON_ARRAY_INSERT(@j, '$[1][1]', 1), JSON_ARRAY_INSERT(@j, '$[2]', 1); 
```
- 删除`json array`元素: `JSON_REMOVE`

```mysql
SET @j = '["a", ["b", "c"], "d"]';
SELECT JSON_REMOVE(@j, '$[1]'); -- ["a", "d"]
SELECT @j; -- ["a", ["b", "c"], "d"]
```

### 2.2 对象

```mysql
SELECT JSON_OBJECT(1, 'A', 2, 'B');
SELECT JSON_TYPE('{"a":1, "b":2}');

-- NULL
SELECT CAST('null' AS JSON);

-- 查看是否包含某个键， 有特殊字符的键必须用双引号，不能用单引号括起来。
SET @col1='$."FAQ.IVR"';
SET @col2='$."FAQ.在线"';
SET @col3='$."FAQ.坐席"';

-- ->
SELECT DOCID, EXATTRS->'$."FAQ.IVR"' AS IVR, 
	EXATTRS->'$."FAQ.在线"' AS 在线 , 
	EXATTRS->'$."FAQ.坐席"' AS 坐席
FROM dynamicDoc 
WHERE JSON_CONTAINS_PATH(EXATTRS, 'ONE', '$."FAQ.IVR"') LIMIT 10;
-- 等价于
SELECT DOCID, JSON_EXTRACT(EXATTRS, '$."FAQ.IVR"') AS IVR, 
	JSON_EXTRACT(EXATTRS, '$."FAQ.在线"') AS 在线 , 
	JSON_EXTRACT(EXATTRS, '$."FAQ.坐席"') AS 坐席
FROM dynamicDoc 
WHERE JSON_CONTAINS_PATH(EXATTRS, 'ONE', '$."FAQ.IVR"') LIMIT 10;

-- 去掉字符串引号
SELECT DOCID, EXATTRS->>'$."FAQ.IVR"' AS IVR, EXATTRS->>'$."FAQ.在线"' AS 在线 , EXATTRS->>'$."FAQ.坐席"' AS 坐席
FROM dynamicDoc 
WHERE JSON_CONTAINS_PATH(EXATTRS, 'ONE', '$."FAQ.IVR"') 
LIMIT 10;

SELECT DOCID, EXATTRS->>'$."FAQ.IVR"' AS IVR, EXATTRS->>'$."FAQ.在线"' AS 在线 , EXATTRS->>'$."FAQ.坐席"' AS 坐席
FROM dynamicDoc
WHERE EXATTRS->>'$."FAQ.IVR"' is not null
LIMIT 10;

SELECT docid, JSON_STORAGE_SIZE(EXATTRS)
FROM dynamicDoc
WHERE EXATTRS->>'$."FAQ.IVR"' is not null
LIMIT 10;
```
### 2.3 常用函数和方法
```mysql
-- JSON_KEYS()查看OBJECT中的键
SELECT DOCID, JSON_KEYS(EXATTRS)
FROM dynamicDoc
WHERE EXATTRS->>'$."FAQ.IVR"' is not null
LIMIT 10;

-- JSON_DEPTH()查看JSON文档的最大深度
SELECT DOCID, JSON_DEPTH(EXATTRS)
FROM dynamicDoc
WHERE EXATTRS->>'$."FAQ.IVR"' is not null
LIMIT 10;

-- 插入元素
SET @l = '{ "a": 1, "b": [2, 3]}';
SELECT JSON_INSERT(@l, '$.a', 10, '$.c', '[true, false]'); -- 已有的不替代
SELECT JSON_INSERT(@l, '$.a', 10, '$.c', CAST('[true, false]' AS JSON));  -- 转换JSON类型

-- 查找JSON对象中元素的个数
SELECT DOCID, JSON_LENGTH(EXATTRS) FROM dynamicDoc LIMIT 20; 

-- JSON转换为MYSQL其它类型
set @v1 = JSON_EXTRACT('{"id": 14, "name": "Aztalan"}', '$.id');
SELECT CAST(@v1 AS UNSIGNED);

-- 更新值 JSON_SET, JSON_INSERT, JSON_REPLACE
SET @j = '{ "a": 1, "b": [2, 3]}';
SELECT JSON_SET(@j, '$.a', 10, '$.c', CAST('[true, false]' AS JSON));
SELECT JSON_SET(@j, '$.a', 10, '$.c', JSON_ARRAY(true, false));

```



>  [`JSON_SET()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-set), [`JSON_INSERT()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-insert) 和[`JSON_REPLACE()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-replace) 等函数的区别:
>
> - [`JSON_SET()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-set) 替换已存在值和插入表中不存在的值.
> - [`JSON_INSERT()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-insert) 插入不存在的值，不替代表中不存在的值.
> - [`JSON_REPLACE()`](https://dev.mysql.com/doc/refman/8.0/en/json-modification-functions.html#function_json-replace) 替代已存在的值，不插入表中不存在的值.

### 2.4 案例

```mysql
-- 创建person表
CREATE TABLE person(id int PRIMARY key, 
	`name` JSON,
	phones JSON,
	address JSON);

-- 插入2行记录
INSERT INTO person
SET id = 10000, 
	`NAME`='{"last_name": "玲", "middle_name": "", "last_name": "王"}',
	phones = '[13567542345, 159762831000]',
	address = '{"country": "中国", "province": "上海", "city": "松江区", "street": {"street_number": 1900, "street_name": "文翔路", "building":"乐群楼"}}';

INSERT INTO person
SET id = 10001, 
	`NAME`='{"last_name": "小明", "middle_name": "", "last_name": "李"}',
	phones = '[18767542135, 189762831010]',
	address = '{"country": "中国", "province": "上海", "city": "虹口区", "street": {"street_number": 5400, "street_name": "高远路", "building":"之行楼"}}';
	
-- 查询
SELECT id, phones->'$[0]', `name`->'$.last_name', address->'$.street.street_name'
FROM person;

-- 更改王玲
UPDATE person
SET `NAME` = JSON_REPLACE(`NAME`, '$.last_name', '王', '$.first_name', '玲')
WHERE id = 10000;

-- 插入：给id为1000的人添加一个新号码18800001111
UPDATE person
SET `phones` = JSON_ARRAY_APPEND(`phones`, '$', 18800001111)
WHERE id = 10000;

SELECT *
FROM person;

-- 插入array元素：给id为1001的人添加一个新号码18800001112，置于最前位置
UPDATE person
SET `phones` = JSON_ARRAY_INSERT(`phones`, '$[0]', 18800001112)
WHERE id = 10001;

-- 深层更新：更新id为1001的人的地址：building为"行知楼"
SELECT id, address
FROM person;
UPDATE person
SET address = JSON_REPLACE(address, '$.street.building', '行知楼')
WHERE id = 10001;;
```

## 3. `prepare statement`



## 4. 窗口函数



